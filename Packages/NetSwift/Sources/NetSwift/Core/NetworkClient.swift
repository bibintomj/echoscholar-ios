//
//  NetworkClient.swift
//  NetSwift
//
//  Created by Bibin Joseph on 2025-04-04.
//

import Foundation

public protocol NetworkSession {
    func data(for request: URLRequest) async throws -> (Data, URLResponse)
    func upload(for request: URLRequest, from bodyData: Data) async throws -> (Data, URLResponse)
}

extension URLSession: NetworkSession {}

/// A thread-safe, configurable networking client for HTTP requests.
public final class NetworkClient {
    private let session: NetworkSession
    private let requestBuilder: RequestBuilder
    private let decoder: JSONDecoder
    private let encoder: JSONEncoder
    private let debugLoggingEnabled: Bool
    
    /// Initialize the `NetworkClient` with custom configurations.
    /// - Parameters:
    ///   - session: `NetworkSession` to customize caching, timeouts, etc.
    ///   - requestBuilder: Custom `RequestBuilder` for request modifications (default: `DefaultRequestBuilder`).
    ///   - decoder: Custom `JSONDecoder` for response parsing (default: `JSONDecoder()`).
    ///   - encoder: Custom `JSONEncoder` for request body encoding (default: `JSONEncoder()`).
    ///   - debugLoggingEnabled: Whether to enable debug logging (default: `false` in production, `true` in debug).
    public init(
        session: NetworkSession = URLSession.shared,
        requestBuilder: RequestBuilder = DefaultRequestBuilder(),
        decoder: JSONDecoder = JSONDecoder(),
        encoder: JSONEncoder = JSONEncoder(),
        debugLoggingEnabled: Bool = false
    ) {
        self.session = session
        self.requestBuilder = requestBuilder
        self.decoder = decoder
        self.encoder = encoder
        #if DEBUG
        self.debugLoggingEnabled = true
        #else
        self.debugLoggingEnabled = debugLoggingEnabled
        #endif
    }
    
    /// Performs a network request and decodes the response.
    public func request<T: Decodable>(_ request: NetworkRequest) async throws -> T {
        let urlRequest = try await requestBuilder.build(from: request)
        logRequest(urlRequest)
        
        do {
            let (data, response) = try await session.data(for: urlRequest)
            logResponse(response, data: data)
            
            guard let httpResponse = response as? HTTPURLResponse else {
                throw NetworkError.invalidResponse
            }
            
            guard (200..<300).contains(httpResponse.statusCode) else {
                logError(statusCode: httpResponse.statusCode, data: data)
                if let decodedError = try? decoder.decode(NError.self, from: data) {
                    throw NetworkError.httpError(statusCode: httpResponse.statusCode, error: decodedError)
                } else {
                    throw NetworkError.httpErrorData(statusCode: httpResponse.statusCode, data: data)
                }
            }
            
            do {
                let decoded = try decoder.decode(T.self, from: data)
                logSuccess(decoded)
                return decoded
            } catch {
                throw NetworkError.decodingError(error)
            }
        } catch {
            logNetworkError(error)
            throw error
        }
    }
    
    // MARK: - Upload Methods
    public func uploadBinary<T: Decodable>(_ request: RawFileUploadRequest) async throws -> T {
        let urlRequest = try await requestBuilder.build(from: request)
        logRequest(urlRequest, fileData: request.fileData)
        
        do {
            let (data, response) = try await session.upload(for: urlRequest, from: request.fileData)
            return try handleResponse(data: data, response: response)
        } catch {
            logNetworkError(error)
            throw error
        }
    }
    
    public func uploadMultipart<T: Decodable>(_ request: MultipartUploadRequest) async throws -> T {
        let urlRequest = try await requestBuilder.build(from: request)
        logRequest(urlRequest, multipartData: request.fileData)
        
        do {
            let (data, response) = try await session.data(for: urlRequest)
            return try handleResponse(data: data, response: response)
        } catch {
            logNetworkError(error)
            throw error
        }
    }
    
    // MARK: - Private Helpers
    private func handleResponse<T: Decodable>(data: Data, response: URLResponse) throws -> T {
        logResponse(response, data: data)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw NetworkError.invalidResponse
        }
        
        guard (200..<300).contains(httpResponse.statusCode) else {
            logError(statusCode: httpResponse.statusCode, data: data)
            if let decodedError = try? decoder.decode(NError.self, from: data) {
                throw NetworkError.httpError(statusCode: httpResponse.statusCode, error: decodedError)
            } else {
                throw NetworkError.httpErrorData(statusCode: httpResponse.statusCode, data: data)
            }
        }
        
        let decoded = try decoder.decode(T.self, from: data)
        logSuccess(decoded)
        return decoded
    }
    
    // MARK: - Debug Logging
    private func logRequest(_ request: URLRequest, fileData: Data? = nil, multipartData: Data? = nil) {
        guard debugLoggingEnabled else { return }
        
        print("\nüåê‚¨ÜÔ∏è [NETWORK REQUEST]")
        print("üîó \(request.httpMethod ?? "GET") \(request.url?.absoluteString ?? "No URL")")
        
        if let headers = request.allHTTPHeaderFields {
            print("\nüìã HEADERS:")
            prettyPrint(headers)
        }
        
        if let body = request.httpBody {
            print("\nüì¶ BODY:")
            if let json = try? JSONSerialization.jsonObject(with: body) {
                prettyPrint(json)
            } else {
                print(String(data: body, encoding: .utf8) ?? "Binary data")
            }
        } else if let fileData = fileData {
            print("\nüì¶ FILE DATA: \(fileData.count) bytes")
        } else if let multipartData = multipartData {
            print("\nüì¶ MULTIPART DATA: \(multipartData.count) bytes")
        }
        
        print("----------------------------------------")
    }
    
    private func logResponse(_ response: URLResponse, data: Data) {
        guard debugLoggingEnabled else { return }
        
        print("\nüåê‚¨áÔ∏è [NETWORK RESPONSE]")
        
        if let httpResponse = response as? HTTPURLResponse {
            print("üü¢ STATUS: \(httpResponse.statusCode)")
            print("üîó URL: \(httpResponse.url?.absoluteString ?? "No URL")")
            
            if !data.isEmpty {
                print("\nüì¶ RESPONSE DATA:")
                if let json = try? JSONSerialization.jsonObject(with: data) {
                    prettyPrint(json)
                } else {
                    print(String(data: data, encoding: .utf8) ?? "Binary data")
                }
            }
        } else {
            print("üü° Non-HTTP response")
        }
        
        print("----------------------------------------")
    }
    
    private func logError(statusCode: Int, data: Data) {
        guard debugLoggingEnabled else { return }
        
        print("\nüåê‚ùå [NETWORK ERROR]")
        print("üî¥ STATUS: \(statusCode)")
        
        if !data.isEmpty {
            print("\nüì¶ ERROR BODY:")
            if let json = try? JSONSerialization.jsonObject(with: data) {
                prettyPrint(json)
            } else {
                print(String(data: data, encoding: .utf8) ?? "Binary data")
            }
        }
        
        print("----------------------------------------")
    }
    
    private func logSuccess<T>(_ decoded: T) {
        guard debugLoggingEnabled else { return }
        
        print("\nüåê‚úÖ [DECODED RESPONSE]")
        prettyPrint(decoded)
        print("----------------------------------------")
    }
    
    private func logNetworkError(_ error: Error) {
        guard debugLoggingEnabled else { return }
        
//        print("\nüåê‚ùóÔ∏è [NETWORK FAILURE]")
        
        if let networkError = error as? NetworkError {
            switch networkError {
            case .invalidURL:
                print("‚ùå Invalid URL")
            case .invalidResponse:
                print("‚ùå Invalid server response")
            case .httpError(let statusCode, let error):
                print("‚ùå HTTP Error: \(statusCode)")
                if let error = error {
                    print("Error details: \(error)")
                }
            case .httpErrorData(let statusCode, let data):
                print("‚ùå HTTP Error: \(statusCode)")
                if let data = data {
                    print("Error details: \(String(data: data, encoding: .utf8) ?? "Binary data")")
                }
            case .decodingError(let error):
                print("‚ùå Decoding error: \(error)")
            case .encodingError(let error):
                print("‚ùå Encoding error: \(error.localizedDescription)")
            case .unknownError(let error):
                print("‚ùå Unknown error: \(error.localizedDescription)")
            }
        } else {
            print("‚ùå \(error.localizedDescription)")
        }
        
        print("----------------------------------------")
    }
    
    private func prettyPrint(_ value: Any) {
        // If the object is Encodable, encode it to JSON and print it nicely
        if let encodableValue = value as? Encodable {
            do {
                let jsonData = try JSONEncoder().encode(AnyEncodable(encodableValue))
                if let jsonObject = try? JSONSerialization.jsonObject(with: jsonData),
                   let prettyData = try? JSONSerialization.data(withJSONObject: jsonObject, options: .prettyPrinted),
                   let prettyString = String(data: prettyData, encoding: .utf8) {
                    print(prettyString)
                    return
                }
            } catch {
                print("‚ùå Failed to encode JSON: \(error)")
            }
        } else {
            print("\(value)")
        }
    }
}

struct AnyEncodable: Encodable {
    private let _encode: (Encoder) throws -> Void

    init<T: Encodable>(_ value: T) {
        _encode = value.encode
    }

    func encode(to encoder: Encoder) throws {
        try _encode(encoder)
    }
}

